{-# LANGUAGE BangPatterns #-}
module Sem05 where

import Prelude hiding(foldr, foldl, foldl', sum, concat)
import Data.Function
import Data.List hiding(insert, foldr, foldl, foldl', sum, concat)

-- Сопоставление с образцом(паттернматчинг)
-- Пусть f определена как
-- f (~t : ~r : ~u : ~ "e") = (:) r $ (:) u [u]
-- Вернет ли f "False" что-нибудь? Почему? Если вернет, то что именно?

-- На каких образцах удачно сматичтся строка "Wow"?
-- (x : y) 
-- ((:) x y)
-- [x, y] 
-- (x : y : z) 
-- (x : [y, z]) 
-- ([x, y, z]) 
-- (x : y : z : []) 
-- (x : y : z : w) 
-- (x : y : z : w : []) 
-- Какие значения будут связаны с переменными при удачном сопоставлении

-- Строгость и форсирование вычислений
-- см main.hs

-- Попробуем побольше поговорить на эту тему сегодня, что бы увидеть,
-- как ленивый язык может подкинуть нам свинью

-- Пусть у нас есть функции свертки списка(что это такое на самом деле, мы пройдем чуть позже)

-- f a1 (f a2 (f a3 ... (f an z)...)))
foldr  f z []     =  z
foldr  f z (x:xs) =  f x (foldr f z xs)

-- f ... (f (f (f z a1) a2) a3) ... an)
foldl  f z []     =  z
foldl  f z (x:xs) =  foldl f (f z x) xs

-- то же самое, что и выше, но строгая
foldl' f z []     =  z
foldl' f z (x:xs) =  (foldl' f $! f z x) xs

-- Первую мы уже видели, когда проходили списки в лямбда-исчислении, заметьте

-- Теперь пусть мы перенесли наше определение суммы элементов списка в Хаскель

sum :: [Integer] -> Integer
sum = foldr (+) 0

-- Попробуйте вызвать что-то типа
-- GHCi> print (sum [1..10000000])
-- У меня на винде довольно быстро пробило стек, а у вас?
-- Почему так, спросите вы. Если посмотреть на определение foldr, то мы увидим, что
-- оно не является tail-recursive. ОДНАКО:

concat :: [[a]] -> [a]
concat = foldr (++) []

-- Автор статьи утверждает, что оно взято из Haskell Report (там-то чуваки знают, мол, что делают!)
-- Пример взят из https://wiki.haskell.org/Stack_overflow
-- И код ниже работает!(На миллиарде мне правда пришлось ждать минут пять)
-- GHCi> print $ length $ concat [[x] | x <- [1..10000000]]

-- Хорошо, давайте попробуем для суммирования использовать не правую, а левую свертку(она tail-recursive)
sum' :: [Integer] -> Integer
sum' = foldl (+) 0
-- Но нет, у меня на миллиарде вообще упало с нечитаемой ошибкой VirtualAlloc MEM_COMMIT failed
-- В чем же причина здесь? Давайте посмотрим, что вообще происходит:

-- sum' [1..10] ->
-- foldl (+) (0) (1 : [2..10]) ->
-- foldl (+) (0 + 1) (2:[3..10]) ->
-- foldl (+) (0 + 1 + 2) (3:[4..10]) -> ...

-- Хаскель ленивый язык и он накапливает в памяти большой невычисленный кусок(thunk или танк,
-- как любит называть его Дима). Решение -- использовать строгий вариант свертки,
-- что бы форсировать вычисление суммы

sum'' :: [Integer] -> Integer
sum'' = foldl' (+) 0

-- Еще усложним себе жизнь. Пусть мы хотим посчитать среднее значение в списке

avg :: Fractional a => [a] -> a
avg = uncurry (/) . foldl' (\(acc, len) x -> (acc + x, len + 1)) (0, 0)

-- Если вы знаете, что такое слабая заголовочная нормальная форма, то вы уже видите проблему:
-- Если нет, то давайте смотреть. seq, сидящий в кишках foldl' вычисляет аргумент до _WHNF_
-- А конструктор примененный к аргументам -- это уже WHNF, так что танк спрячется внутри пар
-- Нужен глубокий seq или BangPatterns

avg' :: Fractional a => [a] -> a
avg' = uncurry (/) . foldl' (\(!acc, !len) x -> (acc + x, len + 1)) (0, 0)

-- Вообще говоря, seq ничего не гарантирует про порядок вычислений
-- Hoogle говорит, что выражение a `seq` b не гарантирует, что a вычислится перед b
-- Единственное, что гарантируется, это то, что оба выражения будут вычислены
-- перед тем, как seq вернет результат

-- Списки и функции над ними
-- В первой части запрещено использовать стандартные функции и генераторы.
-- Разрешена к использованию только рекурсия

-- Найдите количество четных элементов в данном списке
evenCount :: Integral a => [a] -> Integer
evenCount [] = 0
evenCount (x:xs)
            | even x = 1 + evenCount xs
            | otherwise = evenCount xs

-- По данному списку сформируйте список, содержащий только нечетные элементы исходного
onlyOdds :: Integral a => [a] -> [a]
onlyOdds [] = []
onlyOdds (x:xs)
            | odd x = x : onlyOdds xs
            | otherwise = onlyOdds xs

-- Дан список, сформируйте новый, в котором переставлены местами четные и нечетные(по порядку следования)
-- элементы исходного
permuteOddsAndEvens :: [a] -> [a]
permuteOddsAndEvens [] = []
permuteOddsAndEvens (x : y : xs) = y : x : permuteOddsAndEvens xs


-- Даны два списка целых чисел. Сформируйте список, каждый элемент которого -- сумма соответствующих
-- элементов исходных списков. Обеспечьте разумное поведение для списков разной длины
pairwiseSum :: [Integer] -> [Integer] -> [Integer]
pairwiseSum [] _ = []
pairwiseSum _ [] = []
pairwiseSum (x:xs) (y:ys) = x + y : pairwiseSum xs ys

-- Разверните данный список. Постарайтесь обеспечить эффективную реализацию
reverse' :: [a] -> [a]
reverse' [] = []
reverse' (x:xs) = reverse xs ++ [x]

reverse'' = reverseHelper []
    where
        reverseHelper acc [] = acc
        reverseHelper acc (x:xs) = reverseHelper (x:acc) xs


-- Дан список и два числа k и n. Необходимо вытащить подсписок длины n, начиная c k-того по порядку
-- элемента исходного списка. Постарайтесь обеспечить разумное поведение для произвольных целых индексов
slice :: [a] -> Integer -> Integer -> [a]
slice = undefined 


-- Домашнее задание

-- Это предыдущее дз(которое введение в Хаскель), оно короткое 

-- 1. Напишите функцию, которая вычисляет числа Фибоначчи с помощью комбинатора until
-- Посмотрите, какой тип он имеет и как с его помощью добиться желаемого
-- Какова сложность вашего решения?
-- (1б.)
fib :: Integer -> Integer
fib n = fst( snd (until ((>=n) . fst) (\(i, (f1, f2)) -> (i + 1, (f2, f1 + f2))) (0, (0, 1))))

-- 2. Напишите предикат "два числа имеют разную четность" в терминах комбинатора on
-- (1б.)
ofDifferentParity :: Integer -> Integer -> Bool
ofDifferentParity n m = ((/=) `on` odd) n m

-- 3. Напишите функцию, которая считает двойной факториал(произведение всех чисел, не превосходящих данного, имеющих ту же четность)
-- Через fix
-- (1б.)
doubleFacFix :: Integer -> Integer
doubleFacFix = fix (\rec n -> if n <= 1 then 1 else n * rec (n - 2)) 

-- И используя until
-- (1б.)
doubleFacUntil :: Integer -> Integer
doubleFacUntil n = snd (until ((<=1) . fst) (\(i, acc) -> (i - 2, i * acc)) (n, 1))

-- 4. Реализуйте функцию, которая принимает на вход две функции, натуральное число и некоторое начальное значение. 
-- Первую функцию она применяет к каждой цифре числа, а второй "склеивает" все результаты, с заданным начальным значением. Например nat (^2) (+) 0 34 == 25
-- "Склейка" идет справа налево
-- Т.е в примере будет что-то типа 3^2 + 4^2 + 0 
-- (2б.)
nat :: (Integer -> a) -> (a -> b -> b) -> b -> Integer -> b
nat f g ini n = if n <= 9 then g (f n) ini else nat f g (g (f (n `mod` 10)) ini) (n `div` 10)


-- А вот и новое
-- 0. Что не успели на практике. Напишите кучу функций над списками
-- Запрещено использовать явную рекурсию.
-- Разрешается пользоваться только стандартными функциями и генераторами
-- (0.5 балла за каждое)

-- Напишите функцию, которая бы увеличивала все элементы списка в k раз 
multiplyByK :: Num a => [a] -> a -> [a]
multiplyByK xs k = map (*k) xs

-- Напишите функцию, которая бы увеличивала элементы с четными значениями в k раз
multiplyEvensByK :: Integral a => [a] -> a -> [a]
multiplyEvensByK xs k = map (\x -> if odd x then x else x * k) xs

-- Напишите функцию, которая по списку выдает список пар -- (индекс, элемент)
indices :: [a] -> [(Integer, a)]
indices xs = zip  [0..] xs

-- Напишите функцию, которая бы обнуляла элементы данного списка, неудовлетворяющие заданному условию
zeroBy :: [Integer] -> (Integer -> Bool) -> [Integer]
zeroBy xs p = map (\x -> if p x then x else 0) xs

-- Обобщите предыдущую функцию, написав функцию, которая бы применяла к элементам заданного списка,
-- неудовлетворяющим заданному условию заданную функцию
transformBy :: [a] -> (a -> Bool) -> (a -> a) -> [a]
transformBy xs p f = map (\x -> if p x then x else f x) xs

-- Даны три списка целых чисел. Сформируйте список, каждый элемент которого -- сумма соответствующих
-- элементов исходных списков. Длина результата ограничена длиной самого короткого списка
triplewiseSum :: [Integer] -> [Integer] -> [Integer] -> [Integer]
triplewiseSum xs ys zs = map (\(x, y, z) -> x + y + z) (zip3 xs ys zs)

-- 1. Используя функцию nat из предыдущего домашнего задания сформируйте список цифр заданного целого числа
-- (1 балл)

digits :: Integer -> [Integer]
digits x = nat (\x -> x) (:) [] (abs (x))

-- 2. Попробуем написать декартово дерево(для простоты считайте, что ключи явные) на хаскеле. Заведем для него тип данных:

data Treap k v = Node | Branch (Treap k v) (k, v) (Treap k v) deriving Show

-- Вам требуется реализовать все стандартные функции для работы с декартовым деревом:
-- Для простоты считайте, что одинаковых ключей нет, элемент в корне имеет максимальный приоритет
-- split - разрезает декартово дерево tree по ключу key на два -- в одном ключи меньше, либо равные key, а в другом -- большие
-- (1 балл)
split :: Ord k => Treap k v -> k -> (Treap k v, Treap k v)
split Node _  = (Node, Node)
split (Branch l (k, v) r) key | key < k   = let (l', r') = split l key  
                                            in  (l', Branch r' (k, v) r) 
                              | otherwise = let (l', r') = split r key  
                                            in  (Branch l (k, v) l', r')

-- merge - сливает два декартовых дерева tree1 и tree2. Заметьте, что мы никак не проверяем здесь инвариант того, 
-- что ключи у второго дерева больше ключей у первого, поэтому надеяться можно лишь на себя
-- (1 балл)

merge :: Ord v => Treap k v -> Treap k v -> Treap k v
merge Node tree2 = tree2
merge tree1 Node = tree1
merge (Branch l1 (k1, v1) r1) (Branch l2 (k2, v2) r2) | v1 <= v2  = let t = merge (Branch l1 (k1, v1) r1) l2
                                                                    in  (Branch t (k2, v2) r2)
                                                      | otherwise = let t = merge  r1 (Branch l2 (k2, v2) r2)
                                                                    in  (Branch l1 (k1, v1) t)

-- insert -- добавляет в декартово дерево tree элемент с ключом key и значением value
-- (0.5 балла)
insert :: Ord k => Ord v => Treap k v -> k -> v -> Treap k v
insert tree key value = let (l', r') = split tree key
						               in merge (merge l' (Branch Node (key, value) Node)) r'

-- remove -- удаляет из дерева tree значение с ключом key
-- (0.5 балла)
remove :: Ord k => Ord v => Treap k v -> k -> Treap k v
remove Node _ = Node
remove (Branch l (k, v) r) key | k > key  = Branch (remove l key) (k, v) r
                               | k < key  = Branch l (k, v) (remove r key)
                               | otherwise = merge l r

-- build -- из списка пар "ключ-значение" строит декартово дерево
-- (1 балл)
build :: Ord k => Ord v => [(k, v)] -> Treap k v
build pairs = foldr (\x t -> insert t (fst x) (snd x)) Node pairs

-- 3. Пусть у нас есть тип данных Person, который определен как запись:

data Person = Person { firstName :: String, lastName :: String, age :: Int } deriving Show

-- Вот так можно создать например значение этого типа

dude :: Person
dude = Person { firstName = "Jeffrey", lastName = "Lebowsky", age = 50 }

-- А вот таким прикольным способом узнать, как, например, зовут чувака

dudeName :: String
dudeName = firstName dude

-- Иными словами, названия полей работают как селекторы. Заметьте, что задание всех полей при создании 
-- необязательно, но компилятор выдаст предупрежедение, а если вы попробуйте обратиться к полю, которое не
-- было инициализировано, то выкинет исключение

you = Person { firstName = "" }

-- Такой забавный синтаксис позволяет в том числе и "обновлять" значения

duderino = dude { age = 25 }

-- Собственно задание. Пусть у вас есть список людей. Упорядочьте по фамилии всех людей старше 18 лет и младше 65
-- лет, их и верните в качестве результирующего списка
-- (1 балл)
sortedLastNames :: [Person] -> [Person]
sortedLastNames ps = sortBy (compare `on` lastName) (filter (\p -> (age p > 18) && (age p < 65)) ps)

