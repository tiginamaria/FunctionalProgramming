module Sem04 where

import Data.Function(on, fix)
import Data.List(sortBy, sortOn)

-- Начнем с введения в Хаскель.
-- Как мы помним из лекции, у Хаскеля есть компилятор -- GHC
-- который помимо своей основной работы, умеет запускаться в интерактивном режиме.
-- Вообще говоря, весь код дальше я буду показывать в интерпретаторе, а файл нужен
-- чтобы ничего не потерялось

-- Как поставить?
-- Если вы используете Debian-alike дистрибутив, то можно ghc можно поставить 
-- с помощью менеджера пакетов:
-- > apt-get install haskell-platform
-- Есть одно "но": как правило, там стоит старая версия компилятора, что бы 
-- поставить что-то посвежее можно добавить следующий PPA:
-- > sudo add apt-repository ppa:hvr/ghc
-- > sudo apt-get update
-- > sudo apt-get install ghc-8.4.3 (или какой другой версии, какая вам по душе)
--
-- Можно поставить stack и установить все с помощью него.
-- Гайд -- https://wiki.compscicenter.ru/index.php/%D0%A4%D0%9F_2_2016/%D0%9A%D0%B8%D1%80%D0%B8%D0%BB%D0%BB/Install_Haskell

-- Можно зайти на сайт языка и скачать платформу для вашей ОС оттуда:
-- haskell.org/platform

-- Итак, у всех вас уже есть установленный компилятор и менеджер пакетов, 
-- запускается компилятор командой ghc, если вы компилировали что-либо на С++ из
-- командной строки, то все манипуляции будут вам знакомы. Интерактивная оболочка 
-- запускается командой ghci и если вы пользовались питоном или рубями, то вы так
-- же обнаружите много знакомых моментов

-- ghci можно использовать как калькулятор. Например:
-- GHCi> 1 + 1
-- 2
-- GHCi>
--
-- Попробуйте посчитать, чему равно значение выражений:
--
-- 5 * -3
-- 42 `mod` 10
-- 42 `div` 10
-- 42 `rem` 10
-- 42 / 10
-- (-42) `mod` 10
-- (-42) `rem` 10
-- sqrt 4
-- sqrt (-4)
--
--
-- Можно объявлять переменные и функции:
-- GHCi> f x = x
-- GHCi> f 2
-- 2
--
-- В старой литературе и старой версии компилятора для объявления нужно было использовать
-- ключевое слово let(let f x = x, например). Сейчас так уже можно не писать
--
-- GHCi> x = 42
-- GHCi> x = 43
--
-- Обратите внимание, что если я напишу две строчки выше в файле и попробую его откомпилировать,
-- то я получу ошибку компиляции. В модуле не может быть дублирующихся определений.
-- О примере выше лучше думать не как о переменной, а как об определении(ну или как о нульарной функции, если угодно)
--
-- Функции можно объявлять, как выше, выписывая параметры слева от знака равенства, так и с помощью лямбд:
-- GHCi> f = \x -> x
-- GHCi> f 2
-- 2
-- 
-- Для того, что бы тестировать код, который вы пишете, полезно уметь загружать исходный код в интерпретатор.
-- Для этого можно запустить ghci, передав ему параметром имя файла, который вы хотите загрузить:
-- > ghci sem04.hs 
-- Либо будучи в интерпретаторе можно загрузить модуль с помощью команды :load(:l если короче)
--
-- Посмотрим на простые конструкции языка(where, let ... in и так далее)
-- 1. where
--
-- Пусть мы написали функцию, которая считает, сколько сдачи нам должны дать
change given owed = if given - owed > 0 
                    then given - owed
                    else 0

-- Даже в таком простом примере мы повторяемся. Вычитание, конечно, дешевая операция, но повторение кода -- это плохо
-- Для этих целей потребна конструкция where:
change' given owed =    if change > 0
                        then change
                        else 0
    where
        change = given - owed

-- Замететьте, что мы как бы объявили переменную, но после того, как ей воспользовались! Это исправляется с помощью конструкции let ... in:
change'' given owed =   let
                            change = given - owed
                        in 
                            if change > 0 
                            then change
                            else 0

-- Обратите внимание, что блок для else обязателен! Хаскель очень трепетно к этому относится, мы еще про это поговорим
-- Может показаться, что конструкции where и let ничем кроме порядка не отличаются, но это не так. Вторая является выражением -- у него есть тип
-- в то время как where выражением не является. Давайте поймем, как можно бы выразить let и where с помощью лямбда-функций. 
-- Пусть у нас есть высосаный из пальца пример:

sumSqareOrSquareSum x y =   if squareSum > sumSquare
                            then squareSum
                            else sumSquare
    where
        squareSum = (x + y)^2
        sumSquare = x^2 + y^2

-- Давайте избавимся от where просто заинлайнив эти две переменные в тело функции.

sumSquareOrSquareSum' x y = if (x + y)^2 > x^2 + y^2
                            then (x + y)^2
                            else x^2 + y^2
-- Уродство какое, да?
-- Давайте сделаем странную вещь. Представим что у нас есть функция body, которая делает ровно то что нам надо:

body squareSum sumSquare =  if squareSum > sumSquare
                            then squareSum
                            else sumSquare

-- Тогда нашу исходную функцию можно выразить просто как:
sumSquareOrSquareSum'' x y = body ((x + y)^2) (x^2 + y^2)

-- Профит сомнительный, но теперь вспомним, что я говорил, что можно объявлять функции с помощью лямбд и заменим body на лямбду:
sumSquareOrSquareSum''' x y = (\squareSum sumSquare -> if squareSum > sumSquare
                                    then squareSum
                                    else sumSquare) ((x + y)^2) (x^2 + y^2)

-- Смотрите, мы промоделировали переменные с помощью параметров лямбды
-- Поговорим про частичное применение и замыкания. В хаскеле функции являются так называемыми "гражданами первого класса". 
-- Это означает, что их можно передавать и возвращать точно так же, как и все остальные значения. 
-- Самый известный пример использования этого добра -- кастомные компараторы для сортировки. 
-- В С++ это делалось с помощью функторов(которые нифига не функторы, ну да ладно), сейчас все чуточку получше
-- Пусть у нас есть список имен и фамилий:

slayer = [("Hanneman", "Jeff"), ("King", "Kerry"), ("Lombardo", "Dave"), ("Araya", "Tom")]

-- Пусть мы хотим отсортировать его по фамилям. В модуле Data.List есть функция sortBy, которая принимает на вход 
-- компаратор

data Foo = A | B

sortedSlayer = sortBy surnameComparator slayer
    where 
    surnameComparator name1 name2 = if surname1 > surname2
                                    then GT
                                    else    if surname1 < surname2
                                            then LT
                                            else EQ
        where
            surname1 = fst name1
            surname2 = fst name2

-- Смотрите, мы имели доступ к name1 и name2 в теле вспомогательных функций surname1 и surname2
-- Это называется замыканием. Мы еще неоднократно увидим примеры этого добра


-- Еще из забавного, в модуле Data.Function живет известный нам комбинатор неподвижной точки fix и комбинатор on
-- Вспомните определение факториала в лямбда-исчислении и напишите его с помощью fix 

fact = fix (\f n -> if (n == 0) then 1 else n * (f (n - 1)))


-- Комбинатор on позволяет читабельным образом записывать некоторые вещи
-- Например что бы отсортировать участников Slayer по фамилии можно написать следующее:

sortedSlayer'' = sortBy (compare `on` fst) slayer

-- Еще более короткий вариант сортировки по фамилии можно написать с помощью функции sortOn

sortedSlayer' = sortOn fst slayer


-- Домашнее задание:
--
-- 1. Перепишите следующие функции с помощью лямбд: 
-- Обратите внимание, что в этом задании предполагается. что вы воспользуетесь тем фактом, что 
-- конструкция let x = M in N это по сути своей подстановка N[x := M]. То есть в ответе я ожидаю увидеть 
-- некоторую лямбду примененную к некоторому другому значению, как в правиле для бета-редукции
-- (1б.)
overwrite :: Integer -> Integer
overwrite x =   let x = 2
                in 
                    let x = 3
                    in
                        let x = 4
                        in
                            x

-- (2б.)
counter :: Integer -> Integer
counter x = let x = x + 1
            in 
                let x = x + 1
                in
                    x

-- 2. Напишите функцию, которая вычисляет числа Фибоначчи с помощью комбинатора until
-- Посмотрите, какой тип он имеет и как с его помощью добиться желаемого
-- Какова сложность вашего решения?
-- (1б.)
fib :: Integer -> Integer
fib n = until _ _ _

-- 3. Напишите предикат "два числа имеют разную четность" в терминах комбинатора on
-- (1б.)
ofDifferentParity :: Integer -> Integer -> Bool
ofDifferentParity n m = _ `on` _

-- 4. Напишите функцию, которая считает двойной факториал(произведение всех чисел, не превосходящих данного, имеющих ту же четность)

-- Через fix
-- (1б.)
doubleFacFix :: Integer -> Integer
doubleFacFix = fix _

-- И используя until
-- (1б.)
doubleFacUntil :: Integer -> Integer
doubleFacUntil n = until _ _ _

-- 5. Реализуйте функцию, которая принимает на вход две функции, натуральное число и некоторое начальное значение. 
-- Первую функцию она применяет к каждой цифре числа, а второй "склеивает" все результаты, с заданным начальным значением. Например nat (^2) (+) 0 34 == 25
-- (2б.)
nat :: (Integer -> a) -> (a -> b -> b) -> b -> Integer -> b
nat f g ini n = _
